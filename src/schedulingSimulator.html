<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU Scheduling Visualizer</title>
    <style>
        :root {
            --ferrari-red: #ED1C24;
            --ferrari-yellow: #FFD700;
            --ferrari-black: #000000;
            --ferrari-dark: #1E1E1E;
            --ferrari-gray: #333333;
            --ferrari-light: #F5F5F5;
            --ferrari-silver: #C0C0C0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            background-color: var(--ferrari-dark);
            color: var(--ferrari-light);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: var(--ferrari-gray);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            border: 1px solid var(--ferrari-red);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--ferrari-yellow);
        }
        
        .header h1 {
            color: var(--ferrari-red);
            margin-bottom: 5px;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background-color: var(--ferrari-black);
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid var(--ferrari-red);
        }
        
        h2 {
            color: var(--ferrari-yellow);
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 1px solid var(--ferrari-red);
            padding-bottom: 5px;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .input-group label {
            min-width: 120px;
            color: var(--ferrari-yellow);
            font-weight: 500;
        }
        
        input, select {
            padding: 8px 12px;
            border: 1px solid var(--ferrari-red);
            border-radius: 4px;
            background-color: var(--ferrari-dark);
            color: var(--ferrari-light);
            font-size: 0.9rem;
        }
        
        button {
            background-color: var(--ferrari-red);
            color: var(--ferrari-light);
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--ferrari-red);
        }
        
        th {
            background-color: var(--ferrari-red);
            color: var(--ferrari-black);
        }
        
        .visualization {
            background-color: var(--ferrari-black);
            padding: 20px;
            border-radius: 6px;
            margin-top: 20px;
        }
        
        .gantt-container {
            overflow-x: auto;
            margin: 15px 0;
            padding: 15px;
            background-color: var(--ferrari-dark);
            border-radius: 4px;
            border: 1px solid var(--ferrari-red);
        }
        
        .gantt-chart {
            display: flex;
            height: 60px;
            align-items: center;
            min-width: 100%;
        }
        
        .gantt-box {
            padding: 8px;
            border-radius: 3px;
            color: var(--ferrari-black);
            text-align: center;
            min-width: 40px;
            font-weight: bold;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .gantt-box.idle {
            background-color: var(--ferrari-gray);
            color: var(--ferrari-light);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-item {
            background-color: var(--ferrari-dark);
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid var(--ferrari-red);
        }
        
        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        progress {
            width: 100%;
            height: 10px;
            border-radius: 5px;
        }

        /* New styles for execution timeline */
        .execution-timeline {
            margin-top: 20px;
            background-color: var(--ferrari-dark);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--ferrari-red);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .timeline-container {
            overflow-x: auto;
        }

        .timeline-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 2px;
        }

        .timeline-cell {
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--ferrari-gray);
            border-radius: 2px;
            font-size: 0.8rem;
        }

        .timeline-process {
            height: 20px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ferrari-black);
        }

        .timeline-idle {
            background-color: var(--ferrari-gray);
            color: var(--ferrari-light);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CPU SCHEDULING VISUALIZER</h1>
        </div>

        <div class="control-panel">
            <div class="panel process-controls">
                <h2>PROCESS CONTROL</h2>
                <div class="input-group">
                    <label for="process-count">Process Count:</label>
                    <input type="number" id="process-count" min="1" value="5">
                </div>
                <div class="input-group">
                    <label for="input-type">Input Type:</label>
                    <select id="input-type">
                        <option value="manual">Manual Input</option>
                        <option value="random">Random</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button id="generate-processes">Generate Processes</button>
                    <button id="clear-processes">Clear All</button>
                </div>
                <table id="process-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Process</th>
                            <th>Arrival Time</th>
                            <th>Burst Time</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div class="panel algorithm-controls">
                <h2>SCHEDULING ALGORITHM</h2>
                <div class="input-group">
                    <label for="algorithm">Algorithm:</label>
                    <select id="algorithm">
                        <option value="fifo">FIFO</option>
                        <option value="sjf">SJF</option>
                        <option value="srtf">SRTF</option>
                        <option value="rr">Round Robin</option>
                        <option value="mlfq">MLFQ</option>
                    </select>
                </div>
                <div id="rr-controls" style="display: none;">
                    <div class="input-group">
                        <label for="quantum">Time Quantum:</label>
                        <input type="number" id="quantum" min="1" value="4">
                    </div>
                </div>
                <div id="mlfq-controls" style="display: none;">
                    <div class="input-group">
                        <label for="boost-time">Boost Time:</label>
                        <input type="number" id="boost-time" min="1" value="20">
                    </div>
                </div>
            </div>
        </div>

        <div class="visualization">
            <h2>SIMULATION RESULTS</h2>
            <div id="action-message">No Errors.</div>
            
            <h3>GANTT CHART</h3>
            <div class="gantt-container">
                <div class="gantt-chart" id="gantt-chart">
                    No simulation data available. Run simulation to see results.
                </div>
            </div>
            
            <div class="input-group">
                <label for="sim-speed">Simulation Speed:</label>
                <input type="range" id="sim-speed" min="0.1" max="2" step="0.1" value="1">
                <span id="sim-speed-value">1x</span>
            </div>
            
            <h3>PROCESS METRICS</h3>
            <table id="metrics-table">
                <thead>
                    <tr>
                        <th>Process ID</th>
                        <th>Arrival Time</th>
                        <th>Burst Time</th>
                        <th>Completion Time</th>
                        <th>Turnaround Time</th>
                        <th>Waiting Time</th>
                        <th>Response Time</th>
                    </tr>
                </thead>
                <tbody id="metrics-body"></tbody>
            </table>
            
            <div class="metrics">
                <div class="metric-item">
                    <p>Average Waiting Time</p>
                    <span id="avg-wait">--</span>
                </div>
                <div class="metric-item">
                    <p>Average Turnaround Time</p>
                    <span id="avg-tat">--</span>
                </div>
                <div class="metric-item">
                    <p>Average Response Time</p>
                    <span id="avg-resp">--</span>
                </div>
                <div class="metric-item">
                    <p>Total Execution Time</p>
                    <span id="total-exec">--</span>
                </div>
            </div>

            <!-- New Execution Timeline Section -->
            <div class="execution-timeline">
                <h3>PROCESS EXECUTION TIMELINE</h3>
                <div class="timeline-container">
                    <div class="timeline-header">
                        <span>Time Units</span>
                    </div>
                    <div id="timeline-grid" class="timeline-grid"></div>
                </div>
            </div>
            
            <div class="btn-group">
                <button id="simulate">▶ Simulate</button>
                <button id="reset">↻ Reset All</button>
            </div>
        </div>
    </div>

    <script>
        class Process {
            constructor(id, arrivalTime, burstTime) {
                this.id = id;
                this.arrivalTime = arrivalTime;
                this.burstTime = burstTime;
                this.remainingTime = burstTime;
                this.completionTime = 0;
                this.turnaroundTime = 0;
                this.waitingTime = 0;
                this.responseTime = -1;
                this.color = this.getProcessColor(id);
            }
            
            getProcessColor(id) {
                const colors = [
                    '#ED1C24', '#FFD700', '#00A651', '#2E3192', 
                    '#92278F', '#F7931E', '#00AEEF', '#EC008C',
                    '#8DC63F', '#6E2585'
                ];
                return colors[id % colors.length];
            }
        }

        class FIFOScheduler {
            constructor(processes) {
                this.processes = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);
            }
            
            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                
                for (const process of this.processes) {
                    if (currentTime < process.arrivalTime) {
                        ganttChart.push({
                            process: 'IDLE',
                            start: currentTime,
                            end: process.arrivalTime,
                            isIdle: true
                        });
                        currentTime = process.arrivalTime;
                    }
                    
                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }
                    
                    ganttChart.push({
                        process: process.id,
                        start: currentTime,
                        end: currentTime + process.burstTime,
                        color: process.color
                    });
                    
                    currentTime += process.burstTime;
                    process.completionTime = currentTime;
                    process.turnaroundTime = process.completionTime - process.arrivalTime;
                    process.waitingTime = process.turnaroundTime - process.burstTime;
                }
                
                return { ganttChart, processes: this.processes };
            }
        }

        class SJFScheduler {
            constructor(processes) {
                this.processes = processes.map(p => new Process(p.id, p.arrivalTime, p.burstTime));
            }
            
            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const completed = [];
                const readyQueue = [];
                
                while (completed.length < this.processes.length) {
                    this.processes.forEach(p => {
                        if (p.arrivalTime <= currentTime && !completed.includes(p) && !readyQueue.includes(p)) {
                            readyQueue.push(p);
                        }
                    });
                    
                    if (readyQueue.length === 0) {
                        const nextArrival = Math.min(...this.processes
                            .filter(p => !completed.includes(p) && p.arrivalTime > currentTime)
                            .map(p => p.arrivalTime));
                        
                        if (nextArrival !== Infinity) {
                            ganttChart.push({
                                process: 'IDLE',
                                start: currentTime,
                                end: nextArrival,
                                isIdle: true
                            });
                            currentTime = nextArrival;
                            continue;
                        }
                        currentTime++;
                        continue;
                    }
                    
                    readyQueue.sort((a, b) => a.burstTime - b.burstTime);
                    const process = readyQueue.shift();
                    
                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }
                    
                    ganttChart.push({
                        process: process.id,
                        start: currentTime,
                        end: currentTime + process.burstTime,
                        color: process.color
                    });
                    
                    currentTime += process.burstTime;
                    process.completionTime = currentTime;
                    process.turnaroundTime = process.completionTime - process.arrivalTime;
                    process.waitingTime = process.turnaroundTime - process.burstTime;
                    completed.push(process);
                }
                
                return { ganttChart, processes: this.processes };
            }
        }

        class SRTFScheduler {
            constructor(processes) {
                this.processes = processes.map(p => new Process(p.id, p.arrivalTime, p.burstTime));
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const completed = [];
                let lastProcessId = null;

                while (completed.length < this.processes.length) {
                    const readyQueue = this.processes.filter(p =>
                        p.arrivalTime <= currentTime &&
                        p.remainingTime > 0 &&
                        !completed.includes(p)
                    );

                    if (readyQueue.length === 0) {
                        const nextArrival = Math.min(...this.processes
                            .filter(p => !completed.includes(p) && p.arrivalTime > currentTime)
                            .map(p => p.arrivalTime));
                        
                        if (nextArrival !== Infinity) {
                            ganttChart.push({
                                process: 'IDLE',
                                start: currentTime,
                                end: nextArrival,
                                isIdle: true
                            });
                            currentTime = nextArrival;
                            continue;
                        }
                        currentTime++;
                        continue;
                    }

                    readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                    const process = readyQueue[0];

                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    if (lastProcessId === process.id) {
                        ganttChart[ganttChart.length - 1].end = currentTime + 1;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + 1,
                            color: process.color
                        });
                    }

                    process.remainingTime--;
                    currentTime++;
                    lastProcessId = process.id;

                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        process.waitingTime = process.turnaroundTime - process.burstTime;
                        completed.push(process);
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        class RoundRobinScheduler {
            constructor(processes, timeSlice) {
                this.processes = processes.map(p => new Process(p.id, p.arrivalTime, p.burstTime));
                this.timeSlice = timeSlice;
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const queue = [];
                const completed = [];
                const arrived = new Set();

                this.processes.forEach(p => {
                    if (p.arrivalTime <= currentTime) {
                        queue.push(p);
                        arrived.add(p);
                    }
                });

                while (completed.length < this.processes.length) {
                    if (queue.length === 0) {
                        const nextArrival = Math.min(...this.processes
                            .filter(p => !completed.includes(p) && p.arrivalTime > currentTime)
                            .map(p => p.arrivalTime));
                        
                        if (nextArrival !== Infinity) {
                            ganttChart.push({
                                process: 'IDLE',
                                start: currentTime,
                                end: nextArrival,
                                isIdle: true
                            });
                            currentTime = nextArrival;
                            
                            this.processes.forEach(p => {
                                if (p.arrivalTime === currentTime && !arrived.has(p)) {
                                    queue.push(p);
                                    arrived.add(p);
                                }
                            });
                            continue;
                        }
                        currentTime++;
                        continue;
                    }

                    const process = queue.shift();

                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    const execTime = Math.min(this.timeSlice, process.remainingTime);
                    
                    if (ganttChart.length > 0 && 
                        ganttChart[ganttChart.length - 1].process === process.id &&
                        ganttChart[ganttChart.length - 1].end === currentTime) {
                        ganttChart[ganttChart.length - 1].end += execTime;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + execTime,
                            color: process.color
                        });
                    }

                    process.remainingTime -= execTime;
                    currentTime += execTime;

                    this.processes.forEach(p => {
                        if (p.arrivalTime > (currentTime - execTime) && 
                            p.arrivalTime <= currentTime && 
                            !arrived.has(p)) {
                            queue.push(p);
                            arrived.add(p);
                        }
                    });

                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        process.waitingTime = process.turnaroundTime - process.burstTime;
                        completed.push(process);
                    } else {
                        queue.push(process);
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        class MLFQScheduler {
            constructor(processes, boostTime = 20) {
                this.queues = [
                    { quantum: 4, processes: [] },
                    { quantum: 8, processes: [] },
                    { quantum: 16, processes: [] },
                    { quantum: Infinity, processes: [] }
                ];
                this.processes = processes.map(p => new Process(p.id, p.arrivalTime, p.burstTime));
                this.completed = [];
                this.boostTime = boostTime;
                this.lastBoost = 0;
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const arrived = new Set();

                while (this.completed.length < this.processes.length) {
                    if (currentTime - this.lastBoost >= this.boostTime && currentTime !== 0) {
                        for (let i = 1; i < this.queues.length; i++) {
                            while (this.queues[i].processes.length > 0) {
                                const proc = this.queues[i].processes.shift();
                                this.queues[0].processes.push(proc);
                            }
                        }
                        this.lastBoost = currentTime;
                    }

                    this.processes.forEach(p => {
                        if (p.arrivalTime <= currentTime && !arrived.has(p) && p.remainingTime > 0) {
                            this.queues[0].processes.push(p);
                            arrived.add(p);
                        }
                    });

                    let queueIdx = this.queues.findIndex(q => q.processes.length > 0);
                    if (queueIdx === -1) {
                        const nextArrival = Math.min(...this.processes
                            .filter(p => !this.completed.includes(p) && p.arrivalTime > currentTime)
                            .map(p => p.arrivalTime));
                        
                        if (nextArrival !== Infinity) {
                            ganttChart.push({
                                process: 'IDLE',
                                start: currentTime,
                                end: nextArrival,
                                isIdle: true
                            });
                            currentTime = nextArrival;
                            continue;
                        }
                        currentTime++;
                        continue;
                    }

                    const queue = this.queues[queueIdx];
                    const process = queue.processes.shift();

                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    const execTime = Math.min(queue.quantum, process.remainingTime);

                    if (ganttChart.length > 0 &&
                        ganttChart[ganttChart.length - 1].process === process.id &&
                        ganttChart[ganttChart.length - 1].end === currentTime &&
                        ganttChart[ganttChart.length - 1].queue === queueIdx) {
                        ganttChart[ganttChart.length - 1].end += execTime;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + execTime,
                            queue: queueIdx,
                            color: process.color
                        });
                    }

                    process.remainingTime -= execTime;
                    currentTime += execTime;

                    this.processes.forEach(p => {
                        if (p.arrivalTime > (currentTime - execTime) &&
                            p.arrivalTime <= currentTime &&
                            !arrived.has(p) &&
                            p.remainingTime > 0) {
                            this.queues[0].processes.push(p);
                            arrived.add(p);
                        }
                    });

                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        process.waitingTime = process.turnaroundTime - process.burstTime;
                        this.completed.push(process);
                    } else {
                        const nextQueue = Math.min(queueIdx + 1, this.queues.length - 1);
                        this.queues[nextQueue].processes.push(process);
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        class SchedulerVisualizer {
            constructor() {
                this.processes = [];
                this.simulationSpeed = 1.0;
                this.animationInterval = null;
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('input-type').addEventListener('change', (e) => {
                    this.toggleInputType(e.target.value);
                });

                document.getElementById('algorithm').addEventListener('change', (e) => {
                    this.toggleAlgorithmControls(e.target.value);
                });

                document.getElementById('generate-processes').addEventListener('click', () => {
                    this.generateProcesses();
                });

                document.getElementById('clear-processes').addEventListener('click', () => {
                    this.clearProcesses();
                });

                document.getElementById('simulate').addEventListener('click', () => {
                    this.runSimulation();
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.resetAll();
                });

                document.getElementById('sim-speed').addEventListener('input', (e) => {
                    this.simulationSpeed = parseFloat(e.target.value);
                    document.getElementById('sim-speed-value').textContent = `${e.target.value}x`;
                });
            }

            toggleInputType(type) {
                document.getElementById('action-message').textContent = 
                    type === 'manual' ? 'Ready for manual input' : 'Ready to generate random processes';
            }

            toggleAlgorithmControls(algorithm) {
                document.getElementById('rr-controls').style.display = 'none';
                document.getElementById('mlfq-controls').style.display = 'none';

                if (algorithm === 'rr') {
                    document.getElementById('rr-controls').style.display = 'block';
                } else if (algorithm === 'mlfq') {
                    document.getElementById('mlfq-controls').style.display = 'block';
                }
            }

            generateProcesses() {
                const inputType = document.getElementById('input-type').value;
                const count = parseInt(document.getElementById('process-count').value);

                if (isNaN(count) || count <= 0) {
                    document.getElementById('action-message').textContent = 'Invalid number of processes';
                    return;
                }

                this.clearProcessTable();

                if (inputType === 'random') {
                    this.generateRandomProcesses(count);
                } else {
                    this.prepareManualInputTable(count);
                }
            }

            clearProcessTable() {
                const tableBody = document.getElementById('process-table').querySelector('tbody');
                tableBody.innerHTML = '';
                this.processes = [];
            }

            generateRandomProcesses(count) {
                const tableBody = document.getElementById('process-table').querySelector('tbody');
                
                for (let i = 0; i < count; i++) {
                    const arrival = Math.floor(Math.random() * 10);
                    const burst = Math.floor(Math.random() * 10) + 1;
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${i + 1}</td>
                        <td>P${i}</td>
                        <td>${arrival}</td>
                        <td>${burst}</td>
                    `;
                    tableBody.appendChild(row);
                    
                    const process = new Process(i, arrival, burst);
                    this.processes.push(process);
                }
                
                document.getElementById('action-message').textContent = `Generated ${count} random processes`;
            }

            prepareManualInputTable(count) {
                const tableBody = document.getElementById('process-table').querySelector('tbody');
                
                for (let i = 0; i < count; i++) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${i + 1}</td>
                        <td>P${i}</td>
                        <td><input type="number" min="0" class="arrival-time" value="0"></td>
                        <td><input type="number" min="1" class="burst-time" value="1"></td>
                    `;
                    tableBody.appendChild(row);
                }
                
                document.getElementById('action-message').textContent = `Please enter process details for ${count} processes`;
            }

            clearProcesses() {
                this.clearProcessTable();
                document.getElementById('action-message').textContent = 'Process table cleared';
            }

            runSimulation() {
                const inputType = document.getElementById('input-type').value;
                
                if (inputType === 'manual') {
                    this.collectManualInputData();
                }
                
                if (this.processes.length === 0) {
                    document.getElementById('action-message').textContent = 'No processes to simulate';
                    return;
                }

                const algorithm = document.getElementById('algorithm').value;
                let scheduler;

                switch (algorithm) {
                    case 'fifo':
                        scheduler = new FIFOScheduler(this.processes);
                        break;
                    case 'sjf':
                        scheduler = new SJFScheduler(this.processes);
                        break;
                    case 'srtf':
                        scheduler = new SRTFScheduler(this.processes);
                        break;
                    case 'rr':
                        const quantum = parseInt(document.getElementById('quantum').value);
                        scheduler = new RoundRobinScheduler(this.processes, quantum);
                        break;
                    case 'mlfq':
                        const boostTime = parseInt(document.getElementById('boost-time').value);
                        scheduler = new MLFQScheduler(this.processes, boostTime);
                        break;
                    default:
                        document.getElementById('action-message').textContent = 'Invalid algorithm selected';
                        return;
                }

                const result = scheduler.schedule();
                this.displayResults(result);
            }

            collectManualInputData() {
                const rows = document.getElementById('process-table').rows;
                this.processes = [];
                
                for (let i = 1; i < rows.length; i++) {
                    const cells = rows[i].cells;
                    const arrival = parseInt(cells[2].querySelector('input').value);
                    const burst = parseInt(cells[3].querySelector('input').value);
                    
                    if (isNaN(arrival) || isNaN(burst) || burst <= 0) {
                        document.getElementById('action-message').textContent = `Invalid input for process P${i-1}`;
                        return;
                    }
                    
                    const process = new Process(i-1, arrival, burst);
                    this.processes.push(process);
                }
            }

            displayResults(result) {
                this.displayGanttChart(result.ganttChart);
                this.displayMetrics(result.processes);
                this.displayExecutionTimeline(result.ganttChart);
            }

            displayGanttChart(ganttChart) {
                const ganttContainer = document.getElementById('gantt-chart');
                ganttContainer.innerHTML = '';
                
                if (ganttChart.length === 0) {
                    ganttContainer.innerHTML = '<p>No Gantt chart data available</p>';
                    return;
                }

                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                }

                let currentIndex = 0;
                const totalDuration = ganttChart[ganttChart.length - 1].end;
                const updateInterval = 1000 / this.simulationSpeed;

                this.animationInterval = setInterval(() => {
                    if (currentIndex >= ganttChart.length) {
                        clearInterval(this.animationInterval);
                        return;
                    }

                    const entry = ganttChart[currentIndex];
                    const duration = entry.end - entry.start;
                    const box = document.createElement('div');
                    box.className = 'gantt-box';
                    box.style.width = `${duration * 30}px`;
                    box.title = `${duration} units`;
                    
                    if (entry.isIdle) {
                        box.textContent = 'IDLE';
                        box.classList.add('idle');
                    } else {
                        box.textContent = `P${entry.process}`;
                        box.style.backgroundColor = entry.color;
                        
                        if (entry.queue !== undefined) {
                            box.textContent += ` Q${entry.queue}`;
                        }
                    }
                    
                    ganttContainer.appendChild(box);
                    currentIndex++;
                }, updateInterval);
            }

            displayMetrics(processes) {
                let totalTAT = 0;
                let totalWT = 0;
                let totalResp = 0;
                let totalExec = 0;

                const metricsBody = document.getElementById('metrics-body');
                metricsBody.innerHTML = '';

                processes.forEach(p => {
                    p.waitingTime = p.turnaroundTime - p.burstTime;
                    totalTAT += p.turnaroundTime;
                    totalWT += p.waitingTime;
                    totalResp += p.responseTime;
                    totalExec = Math.max(totalExec, p.completionTime);

                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>P${p.id}</td>
                        <td>${p.arrivalTime}</td>
                        <td>${p.burstTime}</td>
                        <td>${p.completionTime}</td>
                        <td>${p.turnaroundTime}</td>
                        <td>${p.waitingTime}</td>
                        <td>${p.responseTime}</td>
                    `;
                    metricsBody.appendChild(row);
                });

                const avgWT = totalWT / processes.length;
                const avgTAT = totalTAT / processes.length;
                const avgResp = totalResp / processes.length;

                document.getElementById('avg-wait').textContent = avgWT.toFixed(2);
                document.getElementById('avg-tat').textContent = avgTAT.toFixed(2);
                document.getElementById('avg-resp').textContent = avgResp.toFixed(2);
                document.getElementById('total-exec').textContent = totalExec;
            }

            displayExecutionTimeline(ganttChart) {
                const timelineGrid = document.getElementById('timeline-grid');
                timelineGrid.innerHTML = '';
                
                if (ganttChart.length === 0) return;

                const totalTime = ganttChart[ganttChart.length - 1].end;
                
                // Create time markers
                for (let i = 0; i <= totalTime; i++) {
                    const timeCell = document.createElement('div');
                    timeCell.className = 'timeline-cell';
                    timeCell.textContent = i;
                    timelineGrid.appendChild(timeCell);
                }
                
                // Create process rows
                const processIds = [...new Set(ganttChart
                    .filter(entry => !entry.isIdle)
                    .map(entry => entry.process))];
                
                processIds.forEach(pid => {
                    const processRow = document.createElement('div');
                    processRow.className = 'timeline-process-row';
                    
                    // Process label
                    const labelCell = document.createElement('div');
                    labelCell.className = 'timeline-cell';
                    labelCell.textContent = `P${pid}`;
                    timelineGrid.appendChild(labelCell);
                    
                    // Process execution blocks
                    const processEntries = ganttChart.filter(entry => entry.process === pid);
                    let currentTime = 0;
                    
                    for (let i = 0; i <= totalTime; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'timeline-cell';
                        
                        const matchingEntry = processEntries.find(entry => 
                            i >= entry.start && i < entry.end);
                        
                        if (matchingEntry) {
                            cell.className = 'timeline-process';
                            cell.style.backgroundColor = matchingEntry.color;
                            cell.textContent = '■';
                        }
                        
                        timelineGrid.appendChild(cell);
                    }
                });
                
                // Add idle row if present
                const hasIdle = ganttChart.some(entry => entry.isIdle);
                if (hasIdle) {
                    const idleLabel = document.createElement('div');
                    idleLabel.className = 'timeline-cell';
                    idleLabel.textContent = 'IDLE';
                    timelineGrid.appendChild(idleLabel);
                    
                    for (let i = 0; i <= totalTime; i++) {
                        const cell = document.createElement('div');
                        cell.className = 'timeline-cell';
                        
                        const isIdle = ganttChart.some(entry => 
                            entry.isIdle && i >= entry.start && i < entry.end);
                        
                        if (isIdle) {
                            cell.className = 'timeline-process timeline-idle';
                            cell.textContent = '■';
                        }
                        
                        timelineGrid.appendChild(cell);
                    }
                }
            }

            resetAll() {
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
                this.processes = [];
                document.getElementById('process-table').querySelector('tbody').innerHTML = '';
                document.getElementById('gantt-chart').innerHTML = 'No simulation data available. Run simulation to see results.';
                document.getElementById('metrics-body').innerHTML = '';
                document.getElementById('timeline-grid').innerHTML = '';
                
                document.getElementById('avg-wait').textContent = '--';
                document.getElementById('avg-tat').textContent = '--';
                document.getElementById('avg-resp').textContent = '--';
                document.getElementById('total-exec').textContent = '--';
                
                document.getElementById('action-message').textContent = 'Ready to simulate';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const visualizer = new SchedulerVisualizer();
        });
    </script>
</body>
</html>
