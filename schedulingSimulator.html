<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPU Scheduling Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4a6fa5;
        }
        .developer {
            color: #7f8c8d;
            font-style: italic;
            text-align: center;
            margin-top: 0;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .control-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .visualization {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
        input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4a6fa5;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #3a5a80;
        }
        .btn-group {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
        }
        .gantt-chart {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            min-height: 60px;
        }
        .gantt-box {
            padding: 8px;
            border-radius: 4px;
            background-color: #e0e0e0;
            text-align: center;
            min-width: 40px;
            position: relative;
        }
        .gantt-box:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 5px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 100;
        }
        .metrics {
            margin-top: 20px;
        }
        .metrics p {
            margin: 5px 0;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #e8f4f8;
            border-radius: 4px;
        }
        .algorithm-controls {
            margin-top: 15px;
            padding: 10px;
            background-color: #f2f2f2;
            border-radius: 4px;
        }
        .speed-control {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        .speed-control input {
            width: 100px;
            margin: 0 10px;
        }
        .progress-container {
            margin-top: 10px;
        }
        progress {
            width: 100%;
        }
        .error {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .process-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .process-input label {
            margin-right: 10px;
            min-width: 100px;
        }
        #process-count {
            width: 60px;
        }
        .metrics-table {
            margin-top: 20px;
            width: 100%;
        }
        .metrics-table th {
            background-color: #4a6fa5;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CPU Scheduling Visualizer</h1>
        <p class="developer">Developed by: VIOLDAN E. BAYOCOT</p>
    </div>

    <div class="container">
        <div class="control-panel">
            <h2>Process Control</h2>
            
            <div class="process-input">
                <label for="input-type">Input Type:</label>
                <select id="input-type">
                    <option value="manual">Manual Input</option>
                    <option value="random">Random Processes</option>
                </select>
            </div>
            
            <div class="process-input">
                <label for="process-count">Number of Processes:</label>
                <input type="number" id="process-count" min="1" value="5">
            </div>

            <div class="btn-group">
                <button id="generate-processes">Generate Processes</button>
                <button id="clear-processes">Clear All</button>
            </div>

            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Process</th>
                        <th>Arrival Time</th>
                        <th>Exec. Time</th>
                        <th>Priority</th>
                    </tr>
                </thead>
                <tbody id="process-table">
                    <!-- Processes will be added here -->
                </tbody>
            </table>

            <div class="algorithm-controls">
                <h3>Scheduling Algorithm</h3>
                <select id="algorithm">
                    <option value="fifo">First-Come First-Served (FIFO)</option>
                    <option value="sjf">Shortest Job First (SJF)</option>
                    <option value="srtf">Shortest Remaining Time First (SRTF)</option>
                    <option value="rr">Round Robin</option>
                    <option value="mlfq">Multilevel Feedback Queue (MLFQ)</option>
                </select>

                <div id="rr-controls" style="display: none; margin-top: 10px;">
                    <label for="quantum">Time Quantum:</label>
                    <input type="number" id="quantum" min="1" value="4">
                </div>

                <div id="mlfq-controls" style="display: none; margin-top: 10px;">
                    <label>MLFQ Time Slices:</label>
                    <div>
                        Q0: <input type="number" class="mlfq-quantum" min="1" value="4">
                        Q1: <input type="number" class="mlfq-quantum" min="1" value="8">
                        Q2: <input type="number" class="mlfq-quantum" min="1" value="16">
                    </div>
                    <label>MLFQ Allotments:</label>
                    <div>
                        Q0: <input type="number" class="mlfq-allotment" min="1" value="8">
                        Q1: <input type="number" class="mlfq-allotment" min="1" value="16">
                        Q2: <input type="number" class="mlfq-allotment" min="1" value="9999">
                    </div>
                    <label for="boost-time">Boost Time:</label>
                    <input type="number" id="boost-time" min="1" value="20">
                </div>
            </div>

            <div class="status">
                <p>Action Message: <span id="action-message">No Errors.</span></p>
            </div>
        </div>

        <div class="visualization">
            <h2>Simulation Results</h2>
            
            <h3>Gantt Chart (Each box represents a second)</h3>
            <div class="gantt-chart" id="gantt-chart">
                <p>No simulation data available. Run simulation to see results.</p>
            </div>

            <div class="metrics">
                <h3>Performance Metrics</h3>
                <p>Average Waiting Time: <span id="avg-wait">--</span></p>
                <p>Average Turnaround Time: <span id="avg-tat">--</span></p>
                <p>Average Response Time: <span id="avg-rt">--</span></p>
                <p>Total Execution Time: <span id="total-exec">--</span></p>
            </div>

            <div class="progress-container">
                <p>CPU: <span id="cpu-status">--</span></p>
                <p>Next Queue: <span id="next-queue">--</span></p>
                <p>Overall Progress: <span id="progress-percent">0</span>%</p>
                <progress id="progress-bar" value="0" max="100"></progress>
            </div>

            <div class="btn-group">
                <button id="simulate">Simulate</button>
                <button id="reset">Reset All</button>
            </div>

            <!-- Metrics Table Added Here -->
            <div class="metrics-table-container">
                <h3>Detailed Process Metrics</h3>
                <table class="metrics-table" id="metrics-table">
                    <thead>
                        <tr>
                            <th>Process</th>
                            <th>Arrival Time</th>
                            <th>Burst Time</th>
                            <th>Completion Time</th>
                            <th>Turnaround Time</th>
                            <th>Waiting Time</th>
                            <th>Response Time</th>
                        </tr>
                    </thead>
                    <tbody id="metrics-body">
                        <!-- Metrics data will be inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        class Process {
            constructor(id, arrivalTime, burstTime) {
                this.id = id;
                this.arrivalTime = arrivalTime;
                this.burstTime = burstTime;
                this.remainingTime = burstTime;
                this.completionTime = 0;
                this.turnaroundTime = 0;
                this.responseTime = -1;
                this.priorityLevel = 0;
                this.timeInQueue = 0;
            }
        }

        class FIFOScheduler {
            constructor(processes) {
                this.processes = [...processes].sort((a, b) => a.arrivalTime - b.arrivalTime);
            }
            
            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                
                for (const process of this.processes) {
                    if (currentTime < process.arrivalTime) {
                        currentTime = process.arrivalTime;
                    }
                    
                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }
                    
                    ganttChart.push({
                        process: process.id,
                        start: currentTime,
                        end: currentTime + process.burstTime
                    });
                    
                    currentTime += process.burstTime;
                    process.completionTime = currentTime;
                    process.turnaroundTime = process.completionTime - process.arrivalTime;
                }
                
                return { ganttChart, processes: this.processes };
            }
        }

        class SJFScheduler {
            constructor(processes) {
                this.processes = processes.map(p => ({
                    ...p,
                    remainingTime: p.burstTime,
                    responseTime: -1,
                    completionTime: 0,
                    turnaroundTime: 0
                }));
            }
            
            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const completed = [];
                const readyQueue = [];
                
                while (completed.length < this.processes.length) {
                    this.processes.forEach(p => {
                        if (p.arrivalTime <= currentTime && !completed.includes(p) && !readyQueue.includes(p)) {
                            readyQueue.push(p);
                        }
                    });
                    
                    if (readyQueue.length === 0) {
                        currentTime++;
                        continue;
                    }
                    
                    readyQueue.sort((a, b) => a.burstTime - b.burstTime);
                    const process = readyQueue.shift();
                    
                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }
                    
                    ganttChart.push({
                        process: process.id,
                        start: currentTime,
                        end: currentTime + process.burstTime
                    });
                    
                    currentTime += process.burstTime;
                    process.completionTime = currentTime;
                    process.turnaroundTime = process.completionTime - process.arrivalTime;
                    completed.push(process);
                }
                
                return { ganttChart, processes: this.processes };
            }
        }

        class SRTFScheduler {
            constructor(processes) {
                this.processes = processes.map(p => ({
                    ...p,
                    remainingTime: p.burstTime,
                    responseTime: -1,
                    completionTime: 0,
                    turnaroundTime: 0
                }));
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const completed = [];
                let lastProcessId = null;

                while (completed.length < this.processes.length) {
                    const readyQueue = this.processes.filter(p =>
                        p.arrivalTime <= currentTime &&
                        p.remainingTime > 0 &&
                        !completed.includes(p)
                    );

                    if (readyQueue.length === 0) {
                        currentTime++;
                        continue;
                    }

                    readyQueue.sort((a, b) => a.remainingTime - b.remainingTime);
                    const process = readyQueue[0];

                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    if (
                        ganttChart.length > 0 &&
                        ganttChart[ganttChart.length - 1].process === process.id
                    ) {
                        ganttChart[ganttChart.length - 1].end = currentTime + 1;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + 1
                        });
                    }

                    process.remainingTime--;
                    currentTime++;
                    lastProcessId = process.id;

                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        completed.push(process);
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        class RoundRobinScheduler {
            constructor(processes, timeSlice) {
                this.processes = processes.map(p => ({
                    ...p,
                    remainingTime: p.burstTime,
                    responseTime: -1,
                    completionTime: 0,
                    turnaroundTime: 0
                }));
                this.timeSlice = timeSlice;
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                const queue = [];
                const completed = [];
                let arrived = [];

                while (completed.length < this.processes.length) {
                    
                    this.processes.forEach(p => {
                        if (p.arrivalTime <= currentTime && !arrived.includes(p)) {
                            queue.push(p);
                            arrived.push(p);
                        }
                    });

                    if (queue.length === 0) {
                        currentTime++;
                        continue;
                    }

                    const process = queue.shift();

                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    const execTime = Math.min(this.timeSlice, process.remainingTime);

                    if (
                        ganttChart.length > 0 &&
                        ganttChart[ganttChart.length - 1].process === process.id &&
                        ganttChart[ganttChart.length - 1].end === currentTime
                    ) {
                        ganttChart[ganttChart.length - 1].end = currentTime + execTime;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + execTime
                        });
                    }

                    process.remainingTime -= execTime;
                    currentTime += execTime;

                    this.processes.forEach(p => {
                        if (p.arrivalTime > (currentTime - execTime) && p.arrivalTime <= currentTime && !arrived.includes(p)) {
                            queue.push(p);
                            arrived.push(p);
                        }
                    });

                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        completed.push(process);
                    } else {
                        queue.push(process);
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        class MLFQScheduler {
            constructor(processes, boostTime = 20, quanta = [4, 8, Infinity], allotments = [8, 16, Infinity]) {
                this.queues = [
                    { quantum: quanta[0], processes: [] },
                    { quantum: quanta[1], processes: [] },
                    { quantum: quanta[2], processes: [] }
                ];
                this.allotments = allotments; 
                this.processes = processes.map(p => ({
                    ...p,
                    remainingTime: p.burstTime,
                    queueLevel: 0,
                    responseTime: -1,
                    completionTime: 0,
                    turnaroundTime: 0,
                    timeInQueue: 0,
                    allotmentUsed: 0
                }));
                this.completed = [];
                this.boostTime = boostTime;
                this.lastBoost = 0;
            }

            schedule() {
                let currentTime = 0;
                const ganttChart = [];
                let arrived = [];

                while (this.completed.length < this.processes.length) {
                    // Boost all processes to top queue if boost time reached
                    if (currentTime - this.lastBoost >= this.boostTime && currentTime !== 0) {
                        for (let i = 1; i < this.queues.length; i++) {
                            while (this.queues[i].processes.length > 0) {
                                const proc = this.queues[i].processes.shift();
                                proc.queueLevel = 0;
                                proc.timeInQueue = 0;
                                proc.allotmentUsed = 0;
                                this.queues[0].processes.push(proc);
                            }
                        }
                        this.lastBoost = currentTime;
                    }

                    // Add arriving processes to top queue
                    this.processes.forEach(p => {
                        if (p.arrivalTime <= currentTime && !arrived.includes(p) && p.remainingTime > 0) {
                            this.queues[0].processes.push(p);
                            arrived.push(p);
                        }
                    });

                    // Find the highest priority non-empty queue
                    let queueIdx = this.queues.findIndex(q => q.processes.length > 0);
                    if (queueIdx === -1) {
                        currentTime++;
                        continue;
                    }
                    
                    let queue = this.queues[queueIdx];
                    let process = queue.processes.shift();

                    // Set response time if this is the first time the process runs
                    if (process.responseTime === -1) {
                        process.responseTime = currentTime - process.arrivalTime;
                    }

                    // Calculate execution time (minimum of quantum, remaining time, and remaining allotment)
                    let allotLeft = this.allotments[queueIdx] - process.allotmentUsed;
                    let execTime = Math.min(queue.quantum, process.remainingTime, allotLeft);

                    // Update Gantt chart
                    if (
                        ganttChart.length > 0 &&
                        ganttChart[ganttChart.length - 1].process === process.id &&
                        ganttChart[ganttChart.length - 1].end === currentTime &&
                        ganttChart[ganttChart.length - 1].queue === queueIdx
                    ) {
                        ganttChart[ganttChart.length - 1].end = currentTime + execTime;
                    } else {
                        ganttChart.push({
                            process: process.id,
                            start: currentTime,
                            end: currentTime + execTime,
                            queue: queueIdx,
                            allotmentUsed: process.allotmentUsed,
                            allotmentLeft: allotLeft - execTime
                        });
                    }

                    // Update process state
                    process.remainingTime -= execTime;
                    process.timeInQueue += execTime;
                    process.allotmentUsed += execTime;
                    currentTime += execTime;

                    // Add any new arrivals during this execution
                    this.processes.forEach(p => {
                        if (
                            p.arrivalTime > (currentTime - execTime) &&
                            p.arrivalTime <= currentTime &&
                            !arrived.includes(p) &&
                            p.remainingTime > 0
                        ) {
                            this.queues[0].processes.push(p);
                            arrived.push(p);
                        }
                    });

                    // Handle process completion or requeueing
                    if (process.remainingTime === 0) {
                        process.completionTime = currentTime;
                        process.turnaroundTime = process.completionTime - process.arrivalTime;
                        this.completed.push(process);
                    } else {
                        // Check if process used up its allotment and should be demoted
                        if (process.allotmentUsed >= this.allotments[queueIdx] && queueIdx < this.queues.length - 1) {
                            process.queueLevel = queueIdx + 1;
                            process.timeInQueue = 0;
                            process.allotmentUsed = 0;
                            this.queues[queueIdx + 1].processes.push(process);
                        } else {
                            // Otherwise, put it back in the same queue
                            this.queues[queueIdx].processes.push(process);
                        }
                    }
                }

                return { ganttChart, processes: this.processes };
            }
        }

        // DOM elements
        const inputTypeSelect = document.getElementById('input-type');
        const processCountInput = document.getElementById('process-count');
        const processTable = document.getElementById('process-table');
        const algorithmSelect = document.getElementById('algorithm');
        const rrControls = document.getElementById('rr-controls');
        const mlfqControls = document.getElementById('mlfq-controls');
        const quantumInput = document.getElementById('quantum');
        const boostTimeInput = document.getElementById('boost-time');
        const generateBtn = document.getElementById('generate-processes');
        const clearBtn = document.getElementById('clear-processes');
        const simulateBtn = document.getElementById('simulate');
        const resetBtn = document.getElementById('reset');
        const ganttChart = document.getElementById('gantt-chart');
        const actionMessage = document.getElementById('action-message');
        const avgWait = document.getElementById('avg-wait');
        const avgTAT = document.getElementById('avg-tat');
        const avgRT = document.getElementById('avg-rt');
        const totalExec = document.getElementById('total-exec');
        const cpuStatus = document.getElementById('cpu-status');
        const nextQueue = document.getElementById('next-queue');
        const progressPercent = document.getElementById('progress-percent');
        const progressBar = document.getElementById('progress-bar');
        const simSpeed = document.getElementById('sim-speed');
        const speedValue = document.getElementById('speed-value');
        const metricsBody = document.getElementById('metrics-body');

        // Process colors
        const processColors = [
            '#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', 
            '#33FFF3', '#FF8C33', '#8C33FF', '#33FF8C', '#FF338C'
        ];

        // Initialize the table with processes
        function initializeTable() {
            processTable.innerHTML = '';
            const count = parseInt(processCountInput.value) || 5;
            
            for (let i = 0; i < count; i++) {
                addProcessRow(i);
            }
        }

        // Add a process row to the table
        function addProcessRow(index) {
            const row = processTable.insertRow();
            const arrival = Math.floor(Math.random() * 10);
            const burst = Math.floor(Math.random() * 10) + 1;
            const priority = Math.floor(Math.random() * 3);
            
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>P${index}</td>
                <td><input type="number" class="arrival-time" min="0" value="${arrival}"></td>
                <td><input type="number" class="burst-time" min="1" value="${burst}"></td>
                <td><input type="number" class="priority" min="0" value="${priority}"></td>
            `;
        }

        // Get processes from the table
        function getProcessesFromTable() {
            const processes = [];
            const rows = processTable.rows;
            
            for (let i = 0; i < rows.length; i++) {
                const cells = rows[i].cells;
                const arrivalInput = cells[2].getElementsByTagName('input')[0];
                const burstInput = cells[3].getElementsByTagName('input')[0];
                
                if (!arrivalInput.value || !burstInput.value) {
                    throw new Error(`Please fill in all arrival and burst times for process P${i}`);
                }
                
                const arrival = parseInt(arrivalInput.value);
                const burst = parseInt(burstInput.value);
                
                if (isNaN(arrival) || arrival < 0) {
                    throw new Error(`Arrival time must be non-negative for process P${i}`);
                }
                
                if (isNaN(burst) || burst <= 0) {
                    throw new Error(`Burst time must be positive for process P${i}`);
                }
                
                processes.push(new Process(i, arrival, burst));
            }
            
            return processes;
        }

        // Render Gantt chart
        function renderGanttChart(ganttData) {
            ganttChart.innerHTML = '';
            
            if (ganttData.length === 0) {
                ganttChart.innerHTML = '<p>No processes were scheduled.</p>';
                return;
            }
            
            ganttData.forEach(entry => {
                const duration = entry.end - entry.start;
                for (let i = 0; i < duration; i++) {
                    const box = document.createElement('div');
                    box.className = 'gantt-box';
                    box.textContent = `P${entry.process}`;
                    box.style.backgroundColor = processColors[entry.process % processColors.length];
                    
                    // Build tooltip with detailed information
                    let tooltip = `Time ${entry.start + i}: P${entry.process}`;
                    if (entry.queue !== undefined) {
                        tooltip += ` (Q${entry.queue})`;
                    }
                    if (entry.allotmentUsed !== undefined) {
                        tooltip += `\nAllotment used: ${entry.allotmentUsed}/${this.allotments ? this.allotments[entry.queue] : 'N/A'}`;
                    }
                    if (entry.allotmentLeft !== undefined) {
                        tooltip += `\nAllotment left: ${entry.allotmentLeft}`;
                    }
                    
                    box.title = tooltip;
                    ganttChart.appendChild(box);
                }
            });
        }

        // Render metrics
        function renderMetrics(processes, ganttData) {
            // Calculate metrics
            const totalWait = processes.reduce((sum, p) => sum + (p.completionTime - p.arrivalTime - p.burstTime), 0);
            const totalTAT = processes.reduce((sum, p) => sum + p.turnaroundTime, 0);
            const totalRT = processes.reduce((sum, p) => sum + p.responseTime, 0);
            const totalExecTime = ganttData.length > 0 ? ganttData[ganttData.length - 1].end : 0;
            
            // Update UI
            avgWait.textContent = (totalWait / processes.length).toFixed(2);
            avgTAT.textContent = (totalTAT / processes.length).toFixed(2);
            avgRT.textContent = (totalRT / processes.length).toFixed(2);
            totalExec.textContent = totalExecTime;
            
            // Update metrics table
            metricsBody.innerHTML = '';
            processes.forEach(p => {
                const row = metricsBody.insertRow();
                const waitingTime = p.completionTime - p.arrivalTime - p.burstTime;
                row.innerHTML = `
                    <td>P${p.id}</td>
                    <td>${p.arrivalTime}</td>
                    <td>${p.burstTime}</td>
                    <td>${p.completionTime}</td>
                    <td>${p.turnaroundTime}</td>
                    <td>${waitingTime}</td>
                    <td>${p.responseTime}</td>
                `;
            });
        }

        // Algorithm selection change
        algorithmSelect.addEventListener('change', function() {
            rrControls.style.display = this.value === 'rr' ? 'block' : 'none';
            mlfqControls.style.display = this.value === 'mlfq' ? 'block' : 'none';
        });

        // Input type change
        inputTypeSelect.addEventListener('change', function() {
            if (this.value === 'random') {
                generateProcesses();
            }
        });

        // Simulation speed change
        simSpeed.addEventListener('input', function() {
            speedValue.textContent = `${this.value}x`;
        });

        // Generate processes button
        generateBtn.addEventListener('click', generateProcesses);

        function generateProcesses() {
            initializeTable();
            actionMessage.textContent = `Generated ${processCountInput.value || 5} random processes.`;
        }

        // Clear processes button
        clearBtn.addEventListener('click', function() {
            processTable.innerHTML = '';
            metricsBody.innerHTML = '';
            actionMessage.textContent = 'Cleared all processes.';
        });

        // Simulate button
        simulateBtn.addEventListener('click', function() {
            try {
                const processes = getProcessesFromTable();
                const algorithm = algorithmSelect.value;
                
                actionMessage.textContent = 'Running simulation...';
                
                let scheduler;
                let result;
                
                switch(algorithm) {
                    case 'fifo':
                        scheduler = new FIFOScheduler(processes);
                        break;
                    case 'sjf':
                        scheduler = new SJFScheduler(processes);
                        break;
                    case 'srtf':
                        scheduler = new SRTFScheduler(processes);
                        break;
                    case 'rr':
                        const quantum = parseInt(quantumInput.value);
                        if (isNaN(quantum) || quantum <= 0) {
                            throw new Error('Time quantum must be a positive number');
                        }
                        scheduler = new RoundRobinScheduler(processes, quantum);
                        break;
                    case 'mlfq':
                        const quanta = Array.from(document.getElementsByClassName('mlfq-quantum')).map(q => parseInt(q.value));
                        const allotments = Array.from(document.getElementsByClassName('mlfq-allotment')).map(a => parseInt(a.value));
                        const boostTime = parseInt(boostTimeInput.value);
                        if (isNaN(boostTime) || boostTime <= 0) {
                            throw new Error('Boost time must be a positive number');
                        }
                        scheduler = new MLFQScheduler(processes, boostTime, quanta, allotments);
                        break;
                }
                
                result = scheduler.schedule();
                renderGanttChart.call(scheduler, result.ganttChart);
                renderMetrics(result.processes, result.ganttChart);
                actionMessage.textContent = 'Simulation completed successfully.';
                
                // Update progress and status
                progressPercent.textContent = '100';
                progressBar.value = 100;
                cpuStatus.textContent = 'Idle';
                nextQueue.textContent = '--';
                
            } catch (e) {
                actionMessage.textContent = 'Error: ' + e.message;
                console.error(e);
            }
        });

        // Reset button
        resetBtn.addEventListener('click', function() {
            ganttChart.innerHTML = '<p>No simulation data available. Run simulation to see results.</p>';
            avgWait.textContent = '--';
            avgTAT.textContent = '--';
            avgRT.textContent = '--';
            totalExec.textContent = '--';
            cpuStatus.textContent = '--';
            nextQueue.textContent = '--';
            progressPercent.textContent = '0';
            progressBar.value = 0;
            metricsBody.innerHTML = '';
            actionMessage.textContent = 'Reset completed. Ready for new simulation.';
        });

        // Initialize the page
        initializeTable();
    </script>
</body>
</html>
